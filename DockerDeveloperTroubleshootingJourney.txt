
*** Troubleshooting Docker Containers Journey ***


Developer Troubleshooting Journey

This project originally began as a multi-module Maven project designed to demonstrate API communication and database access.
During development, several major challenges arose while evolving it from a set of standalone modules into a fully containerized microservices system.

1. Maven Builds and Missing JARs

Initially, we assumed Docker could run my Java source code directly from each module folder.
However, we learned that containers need built JAR artifacts to execute — since Docker isolates its filesystem and doesn’t see local build folders.
This required adding multi-stage Dockerfiles that use Maven to package each service before launching.

2. SQLite Databases Not Found

When the DataAPI started, it failed with:

[SQLITE_ERROR] SQL error or missing database (no such table: incidents)


We discovered SQLite automatically creates new empty files if the database path doesn’t exist inside the container.
The fix was to mount my actual .db files from the host into each container using Docker volumes.
After that, queries worked exactly as expected.

3. Network and Routing Confusion

At first, all API calls used URLs like http://localhost:8081/data/....
Inside Docker, though, localhost refers to the container itself, not other containers.
The fix was learning how Docker’s internal network works — each service is reachable via its container name.
So ClassAPI calls became:

http://dataapi:8081/data/...


and this internal hostname resolved correctly within the shared network.

4. APISIX Route Registration Timing

The APISIX gateway started too slowly for the route registration commands to succeed.
This caused Connection refused errors from the route-init container.
Adding a readiness loop fixed this:

until curl -s -o /dev/null http://apisix:9180/apisix/admin/routes; do
  echo "APISIX not ready yet..."
  sleep 3
done


Now routes are only registered once APISIX is running.

5. Port Mismatch and Debugging

ClassAPI printed that it was “running on port 9080” even though it was actually bound to 8082.
We learned that APISIX forwards traffic from 9080 (external) → 8082 (internal), which clarified how port mapping and routing really worked.

6. Transition from PowerShell to Docker Compose

Originally, the system depended on a PowerShell script (APISIX_START.ps1) to:

Start Docker containers manually

Inject environment variables

Register routes using curl commands

After containerization, all of this was automated inside docker-compose.yml and route-init.
Now the entire project can be launched on any machine with one command:

docker compose up --build


No platform-specific scripting or manual setup is required.

7. Past Lessons Integrated

Some earlier issues (like incorrect JDBC paths, missing class hierarchies, and Maven dependency problems) reinforced consistent debugging strategies — checking environment assumptions, verifying ports, and testing connectivity between APIs using curl inside the Docker network.
This iterative process improved both my understanding of microservice architecture and practical DevOps troubleshooting.

Outcome:
After these iterations, the project now runs fully containerized, with automatic APISIX routing, shared databases, and environment variable configuration.
It’s portable, reproducible, and can be tested by simply cloning the repository and running docker compose up --build.